
/* CncAi 2.5.0 - script.js (single consolidated JS module) */

// Utilities
function toImageData(img, maxW=1024){
  const c=document.createElement('canvas'); const ctx=c.getContext('2d');
  const scale=Math.min(1, maxW/img.width); c.width=Math.round(img.width*scale); c.height=Math.round(img.height*scale);
  ctx.drawImage(img,0,0,c.width,c.height); return ctx.getImageData(0,0,c.width,c.height);
}
function getColormap(name){
  const cm=new Array(256);
  if(name==='gray'){ for(let i=0;i<256;i++) cm[i]=[i,i,i]; return cm; }
  for(let i=0;i<256;i++){ const v=i/255; const r=Math.round(255*Math.max(Math.min(1.5-4*Math.abs(v-0.75),1),0)); const g=Math.round(255*Math.max(Math.min(1.5-4*Math.abs(v-0.5),1),0)); const b=Math.round(255*Math.max(Math.min(1.5-4*Math.abs(v-0.25),1),0)); cm[i]=[r,g,b]; }
  if(name==='hot'){ for(let i=0;i<256;i++){ cm[i]=[Math.min(255,i*2), Math.min(255, Math.max(0,i*2-128)), Math.min(255, Math.max(0,i*2-256))]; } }
  if(name==='cool'){ for(let i=0;i<256;i++){ cm[i]=[Math.round(255*(1 - i/255)), Math.round(255*(i/255)), 255]; } }
  return cm;
}
function applyColormap(imageData, colormap='jet'){
  const w=imageData.width,h=imageData.height; const out=new ImageData(w,h);
  const map=getColormap(colormap); for(let i=0;i<w*h;i++){ const r=imageData.data[i*4], g=imageData.data[i*4+1], b=imageData.data[i*4+2]; const v=Math.round(0.299*r+0.587*g+0.114*b); const [nr,ng,nb]=map[v]; out.data[i*4]=nr; out.data[i*4+1]=ng; out.data[i*4+2]=nb; out.data[i*4+3]=255; }
  return out;
}
function sobelEdge(imageData, threshold=100){
  const w=imageData.width,h=imageData.height; const out=new ImageData(w,h); const gray=new Uint8ClampedArray(w*h);
  for(let i=0;i<w*h;i++) gray[i]=Math.round(0.299*imageData.data[i*4]+0.587*imageData.data[i*4+1]+0.114*imageData.data[i*4+2]);
  const gx=[-1,0,1,-2,0,2,-1,0,1], gy=[-1,-2,-1,0,0,0,1,2,1];
  for(let y=1;y<h-1;y++) for(let x=1;x<w-1;x++){ let sx=0, sy=0, idx=0; for(let ky=-1;ky<=1;ky++) for(let kx=-1;kx<=1;kx++){ const p=gray[(y+ky)*w+(x+kx)]; sx += p*gx[idx]; sy += p*gy[idx]; idx++; } const mag=Math.hypot(sx,sy); const v=mag>threshold?255:0; const pi=(y*w+x)*4; out.data[pi]=out.data[pi+1]=out.data[pi+2]=v; out.data[pi+3]=255; }
  return out;
}
function waitForOpenCV(timeout=10000){ return new Promise((resolve,reject)=>{ const start=Date.now(); (function check(){ if(window.cv && window.cv.Mat) resolve(window.cv); else if(Date.now()-start>timeout) reject(new Error('OpenCV not available')); else setTimeout(check,200); })(); }); }

// Debug
const Debug = {
  el:null,
  init(){ if(this.el) return; this.el=document.createElement('div'); this.el.style.position='fixed'; this.el.style.right='12px'; this.el.style.bottom='12px'; this.el.style.width='360px'; this.el.style.maxHeight='320px'; this.el.style.overflow='auto'; this.el.style.background='rgba(0,0,0,0.7)'; this.el.style.color='#fff'; this.el.style.padding='8px'; this.el.style.fontSize='12px'; this.el.style.borderRadius='8px'; this.el.style.zIndex=9999; this.el.innerHTML='<div style="display:flex;justify-content:space-between;align-items:center"><strong>Debug</strong><div><button id="dbg-clear">Clear</button><button id="dbg-close">Close</button></div></div><div id="dbg-logs" style="margin-top:6px"></div>'; document.body.appendChild(this.el); document.getElementById('dbg-clear').addEventListener('click', ()=>{ document.getElementById('dbg-logs').innerHTML=''; }); document.getElementById('dbg-close').addEventListener('click', ()=>{ this.el.style.display='none'; }); },
  show(){ this.init(); this.el.style.display='block'; },
  hide(){ if(this.el) this.el.style.display='none'; },
  log(msg){ this.init(); const d=document.createElement('div'); d.textContent=(new Date()).toLocaleTimeString()+' — '+msg; document.getElementById('dbg-logs').appendChild(d); }
};

// Task & Memory managers
const TaskManager = { queue:[], running:false, add(taskFn,name='task'){ this.queue.push({taskFn,name}); this._runNext(); }, async _runNext(){ if(this.running) return; const next=this.queue.shift(); if(!next) return; this.running=true; try{ await next.taskFn(); }catch(e){ console.error('Task error',e); Debug.log('Task error: '+e.message); } this.running=false; setTimeout(()=>this._runNext(),10); }, clear(){ this.queue=[]; } };
const MemoryManager = { releaseImage(img){ try{ URL.revokeObjectURL(img.src);}catch(e){} }, releaseCanvas(canvas){ try{ const ctx=canvas.getContext('2d'); ctx && ctx.clearRect(0,0,canvas.width,canvas.height);}catch(e){} } };

// Machine & G-code
const machineSettings = { feed:1200, plunge:2, safeZ:5, units:'mm', mode:'router' };
function g0(x,y,z){ return `G0 X${x.toFixed(3)} Y${y.toFixed(3)} Z${z.toFixed(3)}`; }
function g1(x,y,z,f){ return `G1 X${x.toFixed(3)} Y${y.toFixed(3)} Z${z.toFixed(3)} F${f}`; }
function generateRasterGcode(width_mm, height_mm, step_mm, depth_mm, origin={x:0,y:0}){ const lines=['; Raster G-code generated by CncAi','G21','G90', g0(origin.x, origin.y, machineSettings.safeZ)]; let y=origin.y; const ny=Math.ceil(height_mm/step_mm); for(let j=0;j<ny;j++){ const xStart=origin.x, xEnd=origin.x+width_mm; lines.push(g0(xStart,y,machineSettings.safeZ)); lines.push(g1(xStart,y,-depth_mm,machineSettings.feed)); lines.push(g1(xEnd,y,-depth_mm,machineSettings.feed)); y += step_mm; } lines.push(g0(origin.x, origin.y, machineSettings.safeZ)); return lines.join('\n'); }
function generateContourGcode(contours, depth_mm, origin={x:0,y:0}){ const lines=['; Contour G-code generated by CncAi','G21','G90', g0(origin.x, origin.y, machineSettings.safeZ)]; for(const contour of contours){ if(!contour.length) continue; const start=contour[0]; lines.push(g0(start.x+origin.x, start.y+origin.y, machineSettings.safeZ)); lines.push(g1(start.x+origin.x, start.y+origin.y, -depth_mm, machineSettings.feed)); for(let i=1;i<contour.length;i++){ const p=contour[i]; lines.push(g1(p.x+origin.x, p.y+origin.y, -depth_mm, machineSettings.feed)); } lines.push(g1(start.x+origin.x, start.y+origin.y, -depth_mm, machineSettings.feed)); lines.push(g0(start.x+origin.x, start.y+origin.y, machineSettings.safeZ)); } return lines.join('\n'); }
function downloadGcode(text, filename='output.gcode'){ const blob=new Blob([text],{type:'text/plain'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=filename; document.body.appendChild(a); a.click(); setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); },5000); }

// Modules
let _currentImage=null;
function getCurrentImage(){ return _currentImage; }
function initOriginal(){ const input=document.getElementById('upload-image'); const startBtn=document.getElementById('start-analysis'); const canvas=document.getElementById('image-canvas'); const ctx=canvas.getContext('2d'); input.addEventListener('change',(e)=>{ const file=e.target.files[0]; if(!file) return; const img=new Image(); img.crossOrigin='anonymous'; img.onload=()=>{ const maxW=1536; const scale=Math.min(1, maxW/img.width); canvas.width=Math.round(img.width*scale); canvas.height=Math.round(img.height*scale); ctx.drawImage(img,0,0,canvas.width,canvas.height); _currentImage=img; Debug.log('Loaded image: '+(file.name||'img')+' '+canvas.width+'x'+canvas.height); }; img.src=URL.createObjectURL(file); }); startBtn.addEventListener('click', ()=>{ TaskManager.add(async ()=>{ Debug.log('Starting analysis...'); await new Promise(r=>setTimeout(r,200)); Debug.log('Analysis finished'); }, 'analysis'); }); }
function initHeatmap(){ const canvas=document.getElementById('heatmap-canvas'); const ctx=canvas.getContext('2d'); const colormap=document.getElementById('colormap'); const slider=document.getElementById('edge-sensitivity'); async function regen(){ const img=getCurrentImage(); if(!img) return; const imgData=toImageData(img,1024); canvas.width=imgData.width; canvas.height=imgData.height; try{ const cv=await waitForOpenCV(2500); const src=cv.imread(img); const gray=new cv.Mat(); cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY); const edges=new cv.Mat(); cv.Canny(gray, edges, Number(slider.value), Number(slider.value)*2); const imgData2=new ImageData(new Uint8ClampedArray(edges.data), edges.cols, edges.rows); const mapped=applyColormap(imgData2, colormap.value); ctx.putImageData(mapped,0,0); src.delete(); gray.delete(); edges.delete(); }catch(e){ const edges=sobelEdge(imgData, Number(slider.value)); const mapped=applyColormap(edges, colormap.value); ctx.putImageData(mapped,0,0); } Debug.log('Heatmap regenerated'); } colormap.addEventListener('change', ()=>TaskManager.add(regen,'heatmap')); slider.addEventListener('input', ()=>TaskManager.add(regen,'heatmap')); window.CncAi=window.CncAi||{}; window.CncAi.regenerateHeatmap=()=>TaskManager.add(regen,'heatmap'); }
function findContoursSimple(imgData, thresh=100){ const w=imgData.width,h=imgData.height; const gray=new Uint8ClampedArray(w*h); for(let i=0;i<w*h;i++) gray[i]=Math.round(0.299*imgData.data[i*4]+0.587*imgData.data[i*4+1]+0.114*imgData.data[i*4+2]); const mask=new Uint8Array(w*h); for(let i=0;i<w*h;i++) mask[i]= gray[i]>thresh?255:0; const visited=new Uint8Array(w*h); const contours=[]; function flood(sx,sy){ const stack=[[sx,sy]]; const pts=[]; while(stack.length){ const [x,y]=stack.pop(); if(x<0||y<0||x>=w||y>=h) continue; const idx=y*w+x; if(visited[idx]||mask[idx]===0) continue; visited[idx]=1; pts.push({x,y}); stack.push([x+1,y]); stack.push([x-1,y]); stack.push([x,y+1]); stack.push([x,y-1]); } return pts; } for(let y=0;y<h;y++) for(let x=0;x<w;x++){ const idx=y*w+x; if(!visited[idx] && mask[idx]){ const pts=flood(x,y); if(pts.length>60){ let minx=Infinity,miny=Infinity,maxx=0,maxy=0; for(const p of pts){ if(p.x<minx)minx=p.x; if(p.y<miny)miny=p.y; if(p.x>maxx)maxx=p.x; if(p.y>maxy)maxy=p.y; } contours.push([{x:minx,y:miny},{x:maxx,y:miny},{x:maxx,y:maxy},{x:minx,y:maxy}]); } } } return contours; }
function initContour(){ const btnRaster=document.getElementById('generate-raster'); const btnContour=document.getElementById('generate-contour'); const dl=document.getElementById('download-gcode'); const canvas=document.getElementById('contour-canvas'); const ctx=canvas.getContext('2d'); btnRaster.addEventListener('click', ()=>{ TaskManager.add(async ()=>{ const img=getCurrentImage(); if(!img) return; const imgData=toImageData(img,1024); const g=generateRasterGcode(imgData.width, imgData.height, 5, 1, {x:0,y:0}); downloadGcode(g,'raster.gcode'); Debug.log('Raster G-code generated'); }, 'gcode-raster'); }); btnContour.addEventListener('click', ()=>{ TaskManager.add(async ()=>{ const img=getCurrentImage(); if(!img) return; const imgData=toImageData(img,1024); const contours=findContoursSimple(imgData,100); const g=generateContourGcode(contours,1,{x:0,y:0}); downloadGcode(g,'contour.gcode'); Debug.log('Contour G-code generated: '+contours.length+' contours'); canvas.width=imgData.width; canvas.height=imgData.height; ctx.clearRect(0,0,canvas.width,canvas.height); ctx.strokeStyle='red'; ctx.lineWidth=1; for(const c of contours){ ctx.beginPath(); ctx.moveTo(c[0].x,c[0].y); for(let i=1;i<c.length;i++) ctx.lineTo(c[i].x,c[i].y); ctx.closePath(); ctx.stroke(); } }, 'gcode-contour'); }); }
function initTopView(){ const canvas=document.getElementById('topview-canvas'); const ctx=canvas.getContext('2d'); const legend=document.getElementById('legend'); function render(){ const img=getCurrentImage(); if(!img) return; const imgData=toImageData(img,1024); canvas.width=imgData.width; canvas.height=imgData.height; const mapped=applyColormap(imgData,'jet'); ctx.putImageData(mapped,0,0); legend.textContent='Top View — '+imgData.width+'×'+imgData.height; Debug.log('TopView rendered'); } window.CncAi=window.CncAi||{}; window.CncAi.renderTopView=()=>{ return render(); }; }
function initSimulation(){ const container=document.getElementById('simulation-container'); container.innerHTML=''; const width=container.clientWidth, height=container.clientHeight; const renderer=new THREE.WebGLRenderer({antialias:true}); renderer.setSize(width,height); container.appendChild(renderer.domElement); const scene=new THREE.Scene(); const camera=new THREE.PerspectiveCamera(45,width/height,0.1,1000); camera.position.set(0,-200,200); camera.lookAt(0,0,0); const light=new THREE.DirectionalLight(0xffffff,1); light.position.set(0,0,1); scene.add(light); function build(){ const img=getCurrentImage(); if(!img) return; const imgData=toImageData(img,128); const w=imgData.width,h=imgData.height; const geometry=new THREE.PlaneGeometry(200,200,w-1,h-1); const verts=geometry.attributes.position.array; for(let y=0;y<h;y++) for(let x=0;x<w;x++){ const v=(0.299*imgData.data[(y*w+x)*4]+0.587*imgData.data[(y*w+x)*4+1]+0.114*imgData.data[(y*w+x)*4+2]); const idx=(y*w+x); verts[idx*3+2]=v/255*20; } geometry.computeVertexNormals(); const mat=new THREE.MeshStandardMaterial({color:0x8b5a2b,metalness:0.1,roughness:0.8,side:THREE.DoubleSide}); const mesh=new THREE.Mesh(geometry,mat); mesh.rotation.x=-Math.PI/2; scene.add(mesh); Debug.log('3D built'); } build(); function animate(){ requestAnimationFrame(animate); renderer.render(scene,camera); } animate(); }
document.addEventListener('DOMContentLoaded', ()=>{ Debug.init?.(); initOriginal(); initHeatmap(); initContour(); initTopView(); initSimulation(); const tabs=document.querySelectorAll('.tabs button'); tabs.forEach(btn=>btn.addEventListener('click', ()=>{ tabs.forEach(b=>b.classList.remove('active')); btn.classList.add('active'); const t=btn.dataset.tab; document.querySelectorAll('.tab').forEach(s=>s.classList.remove('active')); const sel=document.getElementById(t); if(sel) sel.classList.add('active'); if(t==='heatmap' && window.CncAi && window.CncAi.regenerateHeatmap) window.CncAi.regenerateHeatmap(); if(t==='topview' && window.CncAi && window.CncAi.renderTopView) window.CncAi.renderTopView(); })); document.getElementById('debug-toggle').addEventListener('click', ()=>{ if(Debug.el && Debug.el.style.display!=='none') Debug.hide(); else Debug.show(); }); document.getElementById('theme-toggle').addEventListener('click', ()=>{ document.documentElement.classList.toggle('light-theme'); }); window.addEventListener('beforeunload', ()=>{ TaskManager.clear(); MemoryManager.releaseCanvas(document.getElementById('image-canvas')); MemoryManager.releaseCanvas(document.getElementById('heatmap-canvas')); }); });
