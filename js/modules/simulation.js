import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js'; import { toImageData } from '../utils.js'; import { Debug } from '../debug.js'; import { getCurrentImage } from './original.js'; export function initSimulation(){ const container=document.getElementById('simulation-container'); container.innerHTML=''; const renderer=new THREE.WebGLRenderer({antialias:true}); renderer.setSize(container.clientWidth, container.clientHeight); container.appendChild(renderer.domElement); const scene=new THREE.Scene(); const camera=new THREE.PerspectiveCamera(45, container.clientWidth/container.clientHeight, 0.1, 1000); camera.position.set(0,-200,200); camera.lookAt(0,0,0); const light=new THREE.DirectionalLight(0xffffff,1); light.position.set(0,0,1); scene.add(light); function build(){ const img=getCurrentImage(); if(!img) return; const imgData=toImageData(img,128); const w=imgData.width,h=imgData.height; const geometry=new THREE.PlaneGeometry(200,200,w-1,h-1); const verts=geometry.attributes.position.array; for(let y=0;y<h;y++) for(let x=0;x<w;x++){ const v=(0.299*imgData.data[(y*w+x)*4]+0.587*imgData.data[(y*w+x)*4+1]+0.114*imgData.data[(y*w+x)*4+2]); const idx=(y*w+x); verts[idx*3+2]=v/255*20; } geometry.computeVertexNormals(); const mat=new THREE.MeshStandardMaterial({color:0x8b5a2b,metalness:0.1,roughness:0.8,side:THREE.DoubleSide}); const mesh=new THREE.Mesh(geometry,mat); mesh.rotation.x=-Math.PI/2; scene.add(mesh); Debug.log('3D built'); } build(); function animate(){ requestAnimationFrame(animate); renderer.render(scene,camera); } animate(); }